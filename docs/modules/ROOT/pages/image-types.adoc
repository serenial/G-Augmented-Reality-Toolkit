= G Augmented-Reality Toolkit's Image Data Representation
: description : Image Data Representation for this toolkit and its relation to other LabVIEW image types
: keywords : image, picture, pixmap, IMAQ, External Data Value Reference, EDVR
:figure-caption!:

Any library or toolkit that deals with image processing needs to start with an understanding of the *Image Data Representation* - that is a common undestanding of how the data which describes an image is arranged and manipulated. This section explains in some detail how this toolkit represents image data and how this compares with the existing native LabVIEW image types.

Those familiar with LabVIEW's native image types and the `IMAQ` image type can skip straight to the section <<G Augmented-Reality Toolkit Image Type, on this toolkit's Image Type>>. For everyone else, lets start with some background. 

== LabVIEW's Image Types

LabVIEW arguably has two "native" image types used to handle graphical data:

[cols="1,.>1"]
|===
a| .The `Pixmap` type 
image::lv-image-type-pixmap.png[]
a| .The `Picture` type
image::lv-image-type-picture.png[]
|===

`Arrays` can also serve as a means of representing graphical data but typically require additional meta-data or context to be rendered to an image. Then there is `IMAQ` which will also be discussed below.

=== Pixmap & Picture

LabVIEW's Pixmap type comes in two forms - `Flattened` and `Unflattened`. 

A `Flattened Pixmap` is a cluster containing a arrays of image, mask and colour data and metadata which describes how that data should be interpreted to build an image. This is that format LabVIEW uses with its built-in VIs for loading and saving images and is quite commonly used in VI-server calls that deal with images.

An `Unflattened Pixmap` is simply pixel data represented by a 2D array of either Booleans, U8s or U32s (depending on the bit-depth). This array might require additional meta-data to be rendered to an image but managing how these related pieces are stored or operated on is down to the developer to manage. Converting a `Flattened Pixmap` to an `Unflattend Pixmap` is typically done to get an easier-to-work-with representation of the pixel data.

If you want to render a `Pixmap` of either type to an image on the front panel you will encouter the other native image type in LabVIEW; a `Picture`.

The `Picture` type is the type LabVIEW associates with the `Picture Control` which is LabVIEW's native way of rendering a two dimensional image on the front panel (ignoring the Intensity Plot). Where a `Picture` type differs from a `Pixmap` is that a `Picture` is just a `string` of "drawing instructions" which the `Picture Control` will follow when it renders out an image.

LabVIEWs `Picture-Function` Palette-VIs which draw shapes and add text to an image these simply append instructions to the instruction-list. Basic shapes are easy to capture as instructions and take up very little memory. One of the instructions allows an arbitrary list of pixels to be rendered which is how LabVIEW allows a `Pixmap` to be drawn to a picture control.

`Pictures` can be "concatinated" using the string concatinate function (_I know, its weird but it is in the docs for the string concatinate node_) or by passing in an existing picture to many VIs which operate on `Pictures`. When `Pictures` are concatinated the internal list of drawing instructions are combined and because of how that list of instructions are rendered (top to bottom) one `Picture` can be overlayed over the other.

Which image type you need to use depends on your use case - if loading and saving images from file using LabVIEW's native functionality or passing images around then a `Flattened Pixmap` makes more sense. If you want to render an image or perform simple drawing operations then a `Picture` is the type to use.

LabVIEW provides utility VIs to convert between `Flattened` and `Unflattend` Pixmaps` and to convert/draw `Pixmaps` to and from `Pictures` but provides very limited image manipulation functionality beyond what we have discussed.

Just before moving on, it is worth remarking that both of these types are _by-value_ - we don't have to worry about the _lifetime_ of this data (if we have the wire, we have the data) and we leave all the memory allocation/deallocation to LabVIEW to handle which eliminates a whole class of potential bugs. In situations where we are performing lots of image operations or passing images around we might encounter performance issues due to image data duplication at times when we, as the omnipotent application developer, know that it need not be duplicated. This can be a reason to look at a _by reference_ approach; this gives the possibility of improving performance but at the expense of having to manage greater complexity. 

The _by-reference_ approach is the one taken by this toolkit - primarily because it is how the images are handled under-the-hood but it also offers better performance when performing multiple processing operations on images as one does in an Augmented Reality application.

=== IMAQ - LabVIEW's "other" Image Type

.The `IMAQ` type
image::lv-image-type-imaq.png[]

The `IMAQ` image type is closely linked to ni's commercially licenced _Vision Acquisition Software_ and _Vision Development Module_. `NI-IMAQ` can be https://www.ni.com/en/support/documentation/supplemental/18/licensing-national-instruments-vision-software.html#section-2109040698[installed and used without activation] although this provides very little functionality beyond the `IMAQ` image control and a minimal number of VIs for handling `IMAQ` type images.

A discussion of how to integrate this toolkit with `NI-IMAQ` will be covered in a later section #TODO:link.

== G Augmented-Reality Toolkit Image Type

This toolkit uses LabVIEW's _External Data Value Reference_ functionality to represent image data. This is a by-reference mechanism for passing image data around in an application which provides more control over when memory is allocated and copied - at the expense of the developer having to be more explicit in the lifetime and usage of image-data in an application.

The toolkit's internals manage memory outside of LabVIEW's normal memory management processes and the usage of _External Data Value References_ (EDVRs) provides the following:

* A means for LabVIEW code to interact directly with the memory allocated by the toolkit's internals.
* A mechanism so the toolkit's internals know when an image is no longer in scope and can be safely deallocated.
* Serialization of access to prevent accidental parallel access which can lead to image corruption.

Image data is represented as either a two-dimensional array of U8s for _Greyscale_ images or as a two-dimensional array of U32s for _Alpha-RGB_ images where the U32 is composed of four 8-bit components arranged as follows.

[cols="1,1"]
|===
| Channel (Colour)
| Bits (0..31)

| Blue
| 0 to 7

| Red
| 8 to 15

| Green
| 16 to 23

| Alpha
| 24 to 31
|===

You will notice that pixel values can only take one of 256 values which might make this toolkit unsuitable for some image processing tasks but it is intended to focus on just the pixel value-range used by webcam devices or typical images intended for use on a desktop or web applications.

Each element of the 2D image array represents a single pixel and pixels are arranged in rows and columns in the same row-major order as a LabVIEW array. `Element [0][0]` is the top left pixel (bear this in mind if rendering the image using an XY plot - the Y-Axis will need to be inverted).

This use of pixel data in this arrangement is directly compatible with the `Unflattened Pixmap` type which uses a U32 for 24-bit depth information (it ignores alpha) and an 8-bit greyscale image (if a suitable `colormap` is also supplied). This pixel data arrangement is also similar to that used by `NI-IMAQ` U32 and U8 image types. 

Armed with this information we can understand how we can work with this image type.

=== Instantiating, Modifying and Deleting 

image::image-types-new-modify-delete-image.png[]

The G-Augmented-Reality Toolkit's Image type follows the same semantics as a regular LabVIEW Data Value Reference - we use `New Image` to create an image EDVR and can access the image-data with an `In Place Element Structure`. When we are finished with the image we can call the `Delete Data Value Reference` node from LabVIEW's `Application Control>>Memory Control` Palette to clean up.

When creating a new image we have the option to specify starting dimensions and a value or we can provide a 2D array of starting image data. `In Place Element` operations are (unsuprisingly) in-place so the image cannot be resized however many of the toolkit's operations on images can modify the image's dimensions automatically so much of the time an "empty" image can be created which will then be resized by the toolkit as required.

If the image is not explicitly deleted then the memory will be safely cleared up when the EDVR reference goes out of scope although it is advisable to `Delete` any images which are no longer required to reduce unecessary memory usage.

[IMPORTANT]
====
The EDVRs used by this toolkit are not compatible with other libraries or toolkits.

* *DO NOT* pass an EDVR created by this toolkit to a different library or toolkit
* *DO NOT* pass an EDVR from a different library or toolkit to any VIs in this toolkit

Your application will probably crash.
====

=== Notes on the Alpha Channel
Whilst the ARGB image type includes an alpha channel which specifies the transparency of each pixel, non of the means provided by this toolkit to rendering an image will respect the alpha channel data. This is primarily due to the lack of direct support for alpha data in the LabVIEW `Picture` indicator. This behaviour is also the same as `NI-IMAQ Image Control`.

Whilst it does not affect rendering, the Alpha channel should be handled appropraitely by the VIs in this toolkit, such as `Resize` etc. and will be written out to files which support alpha data.